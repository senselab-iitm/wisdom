import pandas as pd
import numpy as np

from scripts.data_related import util


'''
:param
    - filepath: relative file path to the ESP32 log file (present in data/human_activity_recognition folder)

:returns
    - esp_df: dataframe with all columns including CSI values. The columns descriptions are given in data/human_activity_recognition/esp_col_desp.md
    - skipped_samples: count of samples in the ESP32 log file that were skipped because they did not have all columns
    - error_samples: count of samples that are included in the dataframe but have some column values as empty
'''
def get_df_from_esp_log(filepath):

    esp_data = {
        'role': [],
        'mac': [],
        'rssi': [],
        'rate': [],
        'sig_mode': [],
        'mcs': [],
        'bw_mode': [],
        'smoothing': [],
        'not_sounding': [],
        'aggregation': [],
        'stbc': [],
        'fec_coding': [],
        'sgi': [],
        'noise_floor': [],
        'ampdu_count': [],
        'channel': [],
        'sec_channel': [],
        'local_timestamp': [],
        'ant': [],
        'sig_len': [],
        'rx_state': [],
        'rel_time_set': [],
        'rel_timestamp': [],
        'csi_len': [],
        'iq_vals': []
    }

    with open(filepath, 'r') as ip_file:
        skipped_samples = 0
        for line in ip_file:

            samples = list(filter(None, line.split('CSI_DATA')))
            if len(samples) == 0:
                continue

            for sample in samples:
                attributes = list(filter(None, sample.split(',')))
                if len(attributes) != 25:
                    skipped_samples += 1  # Not all column values are present
                    continue

                iq_vals_str = attributes[-1]
                iq_val_list_str = list(filter(None, iq_vals_str.replace('[', '').replace(']', '').split()))
                if len(iq_val_list_str) != 128:
                    esp_data['iq_vals'].append(np.nan)  # Not all IQ values are present
                else:
                    try:
                        iq_val_list_int = list(map(int, iq_val_list_str))
                        esp_data['iq_vals'].append(iq_val_list_int)
                    except ValueError:
                        esp_data['iq_vals'].append(np.nan)  # All IQ values are not integers

                # Adding the different column values from log file and converting to appropriate data type
                esp_data['role'].append(attributes[0])
                esp_data['mac'].append(attributes[1])
                esp_data['rssi'].append(util.convert_to_int(attributes[2]))
                esp_data['rate'].append(util.convert_to_int(attributes[3]))
                esp_data['sig_mode'].append(util.convert_to_int(attributes[4]))
                esp_data['mcs'].append(util.convert_to_int(attributes[5]))
                esp_data['bw_mode'].append(util.convert_to_int(attributes[6]))
                esp_data['smoothing'].append(util.convert_to_boolean(attributes[7]))
                esp_data['not_sounding'].append(util.convert_to_boolean(attributes[8]))
                esp_data['aggregation'].append(util.convert_to_boolean(attributes[9]))
                esp_data['stbc'].append(util.convert_to_boolean(attributes[10]))
                esp_data['fec_coding'].append(util.convert_to_boolean(attributes[11]))
                esp_data['sgi'].append(util.convert_to_boolean(attributes[12]))
                esp_data['noise_floor'].append(util.convert_to_int(attributes[13]))
                esp_data['ampdu_count'].append(util.convert_to_int(attributes[14]))
                esp_data['channel'].append(util.convert_to_int(attributes[15]))
                esp_data['sec_channel'].append(util.convert_to_int(attributes[16]))
                esp_data['local_timestamp'].append(util.convert_to_int(attributes[17]))
                esp_data['ant'].append(util.convert_to_int(attributes[18]))
                esp_data['sig_len'].append(util.convert_to_int(attributes[19]))
                esp_data['rx_state'].append(util.convert_to_int(attributes[20]))
                esp_data['rel_time_set'].append(util.convert_to_int(attributes[21]))
                esp_data['rel_timestamp'].append(util.convert_to_float(attributes[22]))
                esp_data['csi_len'].append(util.convert_to_int(attributes[23]))

    esp_df = pd.DataFrame(esp_data)
    error_samples = len(esp_df[esp_df.isnull().any(axis=1)])
    return skipped_samples, error_samples, esp_df


'''
:param
    - esp_df: dataframe that is generated by get_df_from_esp_log function
    
:returns
    - csi_spectogram: spectrogram of complex numbers that represents the CSI IQ values in the entire dataframe (esp_df)
'''
def get_csi_spectogram_from_esp_df(esp_df):

    iq_vals_list = esp_df[esp_df.iq_vals.isnull() == False]['iq_vals'].tolist()
    iq_vals_matrix = np.array(iq_vals_list)

    csi_spectogram = []
    for idx in range(0, 128, 2):
        csi_spectogram.append(iq_vals_matrix[:, idx] + 1j * iq_vals_matrix[:, idx + 1])
    csi_spectogram = np.array(csi_spectogram).transpose()
    csi_spectogram = np.concatenate((csi_spectogram[:, 6:31], csi_spectogram[:, 33:58]), axis=1)

    return csi_spectogram


'''
:param
    - csi_spectogram: spectogram of CSI IQ values generated by get_csi_spectogram_from_esp_df
    - segment_length: number of samples to which we want to divide the spectograms
    
:returns
    - segments: list of spectograms of length segment_length, generated from csi_spectogram (generated from entire dataframe)
'''
def get_csi_spectogram_segments(csi_spectogram, segment_length):

    segments = np.split(
        csi_spectogram,
        np.arange(segment_length, len(csi_spectogram), segment_length)
    )

    if len(segments[-1]) != segment_length:
        segments = segments[:len(segments) - 1]

    return segments


'''
:param
    - annotations_for_files: list of annotations, where each annotation corresponds to a list of files that have the esp logs
    - segment_length: number of samples to which we want for a spectogram
    - flatten: suppose we have M X N spectogram. If flatten is true we get (M*N) length vector, else the spectogram remain as M X N matrix.
    
:returns
     - csi_segments: list of spectograms of length segment_length for all files.
     - annotations: list of annotations, where each annotation corresponds to the class of the spectogram in csi_segments list
'''
def get_annotated_csi_segments_from_esp_logs(annotations_for_files, segment_length, flatten):

    annotations = []
    csi_segments = []

    for annotation, files in annotations_for_files.items():
        for file in files:

            _, _, esp_df_for_file = get_df_from_esp_log(file)

            csi_spectogram_for_file = get_csi_spectogram_from_esp_df(esp_df_for_file)
            # Remove first and last 10 seconds of data, as we are moving around to start ot stop the script
            csi_spectogram_for_file = csi_spectogram_for_file[1500:-1500]
            csi_segments_for_file = get_csi_spectogram_segments(csi_spectogram_for_file, segment_length)
            csi_segments.append(csi_segments_for_file)

            annotations = annotations + [annotation] * len(csi_segments_for_file)
            print('Annotated file: {}'.format(file))

        print('Annotated all files for annotation: {}'.format(annotation))

    annotations = np.array(annotations)

    csi_segments = np.concatenate(csi_segments)
    if flatten:
        csi_segments = np.reshape(csi_segments, (csi_segments.shape[0], csi_segments.shape[1] * csi_segments.shape[2]))

    return csi_segments, annotations


'''
:param
    - csi: a CSI spectogram of complex values

:returns
    - csi_amp: CSI spectogram of same dimensions as input csi, but having the amplitudes of the complex values
'''
def get_amplitudes(csi):

    csi_amp = abs(csi).astype(np.float32)
    max = np.percentile(csi_amp, 99)
    csi_amp[np.nonzero(csi_amp > max)] = max

    return csi_amp